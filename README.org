* Prerequisites
  Before using this init file one should ensure to have
*** cmake
*** git
*** rtags (optional)
*** Be sure your .emacs file does not contain any "custom"-like lines generated by emacs itself. If it does and prevent you from initializing, remove these lines and try to clean up your ~/.emacs.d directory
*** Create .emacs.d/snippets/ folder and create symlink .emacs.d/snippets/org-mode to my-github-emacs/custom/snippets/org-mode
* Basic customization
** Emacs init infrastructure
#+BEGIN_SRC emacs-lisp
  (require 'package)
#+END_SRC

Important line. It initializes some installed packages (which cannot be initialized with their default auto-(require 'helm-gtags).
For helm-gtags to be found.
#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

  Add additional package sources
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  #+END_SRC

  In case I'm on work machine, use https instead of http
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
    (add-to-list 'package-archives '("gnu" . "https://elpa.gnu.org/packages/"))
  #+END_SRC

  Load updates from these sources. Or 'use-package' will not be available
  #+BEGIN_SRC emacs-lisp
    (when (not package-archive-contents)
      (package-refresh-contents))
  #+END_SRC

  Install 'use-package'
  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-install 'use-package))
  #+END_SRC

  Make all the packages be loaded with 'use-package' instruction
  #+BEGIN_SRC emacs-lisp
    (require 'use-package)
    (setq use-package-always-ensure t)
  #+END_SRC

  To enable emacs-client programm for committing
  #+BEGIN_SRC emacs-lisp
    (use-package server)
    (unless (server-running-p) (server-start))
  #+END_SRC

  To remove: old init files
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'load-path "~/.emacs.d/custom")
  #+END_SRC

** Edit/remove toolbars/windows etc
Remove unnecessary windows
#+BEGIN_SRC emacs-lisp
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Hide startup screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

  Maximize screen on starup
  #+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  #+END_SRC

  Speedbar customization
  #+BEGIN_SRC emacs-lisp
    (use-package sr-speedbar)
    (global-set-key "\C-c\C-s" 'sr-speedbar-toggle)
    (setq speedbar-show-unknown-files t)
    (setq sr-speedbar-right-side nil)
    (setq sr-speedbar-skip-other-window-p t)
  #+END_SRC

Enable filebrowser on the left
#+BEGIN_SRC emacs-lisp
  ;;(global-set-key "\C-s\C-n" `neotree-toggle)
#+END_SRC

Commands to switch windows in the same frame
#+BEGIN_SRC emacs-lisp
  ;; (global-set-key "\C-cb" 'windmove-left)
  ;; (global-set-key "\C-cf" 'windmove-right)
  ;; (global-set-key "\C-cp" 'windmove-up)
  ;; (global-set-key "\C-cn" 'windmove-down)
(global-set-key "\C-xp" (lambda () (interactive) (other-window -1)))
#+END_SRC

** Styles
Themes
#+BEGIN_SRC emacs-lisp
;;(load-theme 'northcode)
(load-theme 'tango-dark)
#+END_SRC

** Org-mode
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-c c") 'org-content)
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (defun org-fitness-goto-table (name)
    "Go to table named NAME if point is not in any table."
    (unless (org-at-table-p)
      (let ((org-babel-results-keyword "NAME"))
        (org-babel-goto-named-result name)
        (forward-line 2))))

  (defun org-fitness-sum-rectangle ()
    "Sum values in marked rectangle."
    (interactive)
    (message "%s: %.2f"
             (org-fitness-column-name-at-point)
             (->> (extract-rectangle (region-beginning) (region-end))
                  (-map 'string-to-number)
                  (-sum))))

  (defmacro org-with-table (table-name &rest body)
    "Move point to inside Org table TABLE-NAME and execute BODY."
    (declare (indent defun))
    `(org-with-wide-buffer
      (let ((org-babel-results-keyword "NAME"))
        (org-babel-goto-named-result ,table-name)
        (forward-line 2)
        ,@body)))

  (defun org-table-name-at-point ()
    "Return name of table at point."
    (org-with-wide-buffer
     (goto-char (org-table-begin))
     (forward-line -1)
     (beginning-of-line)
     (re-search-forward (rx "#+NAME:" (1+ space) (group (1+ (not space))) eol))
     (match-string-no-properties 1)))

  (defun org-table-column-names (&optional table-name)
    "Return list of column names for TABLE-NAME or table at point."
    (org-with-table
     (or table-name (org-table-name-at-point))
     (org-table-analyze)
     (--map (org-no-properties (car it))
            org-table-column-names)))

  (defun org-fitness-timestamp-at-point ()
    "Return any Org timestamp at point, or nil."
    (when (org-at-timestamp-p t) (match-string-no-properties 0)))

  (defun org-fitness-column-names-at-point ()
    "Return list of column names for table at point."
    (org-table-analyze)
    (--map (org-no-properties (car it))
           org-table-column-names))

  (defun org-fitness-column-name-at-point ()
    "Return name of column at point."
    (let ((column (org-table-current-column)))
      (org-with-wide-buffer
       (org-table-goto-line 0)
       (s-trim (substring-no-properties (org-table-get-field column))))))

  (defun org-fitness-table-name-at-point ()
    (org-with-wide-buffer
     (goto-char (org-table-begin))
     (forward-line -1)
     (beginning-of-line)
     (re-search-forward (rx "#+NAME:" (1+ space) (group (1+ (not space))) eol))
     (match-string-no-properties 1)))

  (defun org-fitness-sum-column (&optional table column date)
    "Return sum of COLUMN in TABLE for DATE.
  TABLE should be the name of an Org table. If nil and point is in
  a table, the current table will be used.

  DATE should be an Org timestamp. If nil and point is on a
  timestamp, DATE will be picked up from point.  If just nil, date
  will be ignored.

  COLUMN should be the name of a column's header field. If nil and
  the point is in an Org table, the name of the current column will
  be used."
    (interactive)
    (let* ((table (or table (org-fitness-table-name-at-point)))
           (column (or column (org-fitness-column-name-at-point)))
           (ts-at-point (org-fitness-timestamp-at-point))
           (date (or date
                     (when (and ts-at-point
                                (org-at-table-p))
                       ;; TODO: Use a function to get the date column index
                       (org-with-wide-buffer (org-table-get-field 2)))))
           (sum (-sum (-map 'string-to-number
                            (-flatten (org-fitness-select-columns table (list column) date))))))
      ;; (if (floatp sum)
      ;; (format "%0.2f" sum)
      ;; sum)
      sum))

  (defun org-fitness-select-columns (table-name column-names &optional date)
    "Return list of rows with selected COLUMN-NAMES in TABLE-NAME for DATE.

  COLUMN-NAMES is a list of strings.

  If DATE is nil, ignore date.  If DATE is symbol `today', today's
  date will be used.

  This function expects the table to have a header row in which the
  date column is named \"Date\" and contains Org timestamps."
    (let* ((org-extend-today-until 4)
           (day-number (cond
                        ((null date) nil)
                        ((equal date 'today) (org-today))
                        (date (1+ (date-to-day date)))))
           (table-data (--remove (or (equal 'hline it)
                                     ;; Remove lines without a date (second column)
                                     (string-empty-p (nth 1 it)))
                                 (org-with-table table-name
                                                 (org-table-to-lisp))))
           (header (car table-data))
           (date-column-number (--find-index (string= "date" (downcase it)) header))
           (column-numbers
            ;; The indexes of the columns we need to "pre-select", including the date, even if the date is not being returned
            (-sort '< (-uniq (--map (-find-index (-partial 'string= it) header)
                                    column-names))))
           (final-columns
            ;; The adjusted indexes of the columns we're returning, after they've been pre-selected
            (number-sequence 1 (length column-numbers))))
      (->> (cdr table-data)               ; Remove header
           (-select-columns (cons date-column-number column-numbers))
           ((lambda (row)
              (if (null day-number)
                  row
                (--filter (= day-number
                             (->> (car it) ; Date column is first
                                  (org-time-string-to-time)
                                  (time-to-days)))
                          row))))

           ;; Remove date column if not requested
           (-select-columns final-columns))))

  (defun org-fitness-remove-columns-by-indices (indices table)
    "Return TABLE without columns specified by INDICES.
  INDICES is a list of integers and TABLE is a list of lists."
    (let* ((num-columns (length (car table)))
           (columns (-remove (lambda (col)
                               (memq col indices))
                             (number-sequence 0 (1- num-columns)))))
      (-select-columns columns table)))
#+END_SRC

** History/backup
   Save sessions history to ~/.emacs.d/savehist file
#+BEGIN_SRC emacs-lisp
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring search-ring regexp-search-ring compile-history log-edit-comment-ring)
      savehist-file "~/.emacs.d/savehist")
(savehist-mode t)
#+END_SRC

Write backups to ~/.emacs.d/backup/
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "/home/vkocheganov/.emacs.d/backup"))
      backup-by-copying      t  ; Don't de-link hard links
      version-control        t  ; Use version numbers on backups
      delete-old-versions    t  ; Automatically delete excess backups:
      kept-new-versions      20 ; how many of the newest versions to keep
      kept-old-versions      5) ; and how many of the old
#+END_SRC

** Others
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;; Show column number (along with line number) ;;;;;;;;;;
  ;;(column-number-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;(require 'setup-cedet)
#+END_SRC

Garbage collector bytes threshold
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
#+END_SRC

Comment only region, not the lines. Makes sense when comment several lines
#+BEGIN_SRC emacs-lisp
(setq cd2/region-command 'cd2/comment-or-uncomment-region)
#+END_SRC

** Some key mappings
Make things faster (basics from https://sites.google.com/site/steveyegge2/effective-emacs)
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-m" 'execute-extended-command)
(global-set-key "\C-w" 'backward-kill-word)
(global-set-key "\C-x\C-k" 'kill-region)
#+END_SRC

Commands to deal with registers
Use C-x r i to insert FROM register
Use C-x r s r to insert TO register
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-xra" `append-to-register)
(global-set-key "\C-xrp" `prepend-to-register)
#+END_SRC

activate whitespace-mode to view all whitespace characters
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
   ;;(define-key undo-tree-map (kbd "C-_") 'undo-tree-redo)
  ;;; (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
    (which-key-mode))
#+END_SRC
** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :init
;;  (global-company-mode 1)
;;  (delete 'company-semantic company-backends)
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 3)
  (add-hook 'c-mode-common-hook 'company-mode)
  (add-hook 'shell-mode-hook 'company-mode)
  (add-hook 'lisp-mode-hook 'company-mode)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (unless (package-installed-p 'irony)
    (package-install 'irony)
    (shell-command (concat "echo " (shell-quote-argument (read-passwd "Password? "))
                           " | sudo -S apt-get install --assume-yes clang libclang-dev"))
    (call-interactively #'irony-install-server)
    )

  (use-package irony
    :config
    (add-hook 'c-mode-common-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'my-irony-mode-hook)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  ;;;;;;;;;; Auto-complete c headers ;;;;;;;;;;
    (use-package company-irony-c-headers
      :config
      (add-to-list 'company-backends 'company-irony-c-headers)
      )

    (use-package company-irony
      :config
      (add-to-list 'company-backends 'company-irony)
      )

    (use-package flycheck-irony
      :config
      (eval-after-load 'flycheck '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
      (add-hook 'c-mode-common-hook 'flycheck-mode)
      )

    (use-package irony-eldoc
      :config
      (add-hook 'irony-mode-hook #'irony-eldoc)
      )
    )
  )

(with-eval-after-load 'company
  (define-key company-active-map (kbd "M-p") nil)
  (define-key company-active-map (kbd "M-n") nil)
  (define-key company-active-map (kbd "C-n") #'company-select-next)
  (define-key company-active-map (kbd "C-p") #'company-select-previous))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; for irony mode to work one needs to run 'irony-install-server'. Be sure to install clang + libclang-dev ;;      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(with-eval-after-load 'company
  (add-hook 'c-mode-common-hook 'company-mode)
  ;; (add-to-list
  ;;   'company-backends '(company-irony-c-headers company-irony))
  )
(add-hook 'c-mode-common-hook
          (lambda ()
            (define-key c-mode-base-map  [(tab)] 'company-indent-or-complete-common)
            )
          )
#+END_SRC
* Editing
#+BEGIN_SRC emacs-lisp
;; GROUP: Editing -> Editing Basics
(setq global-mark-ring-max 5000         ; increase mark ring to contains 5000 entries
      mark-ring-max 5000                ; increase kill ring to contains 5000 entries
      mode-require-final-newline t      ; add a newline to end of file
      tab-width 4                       ; default to 4 visible spaces to display a tab
      )

(add-hook 'sh-mode-hook (lambda ()
                          (setq tab-width 4)))

(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)

(setq-default indent-tabs-mode nil)
(delete-selection-mode)
(global-set-key (kbd "RET") 'newline-and-indent)

;; GROUP: Editing -> Killing
(setq kill-ring-max 5000 ; increase kill-ring capacity
      kill-whole-line t  ; if NIL, kill whole line and move the next line up
      )

;; show whitespace in diff-mode
(add-hook 'diff-mode-hook (lambda ()
                            (setq-local whitespace-style
                                        '(face
                                          tabs
                                          tab-mark
                                          spaces
                                          space-mark
                                          trailing
                                          indentation::space
                                          indentation::tab
                                          newline
                                          newline-mark))
                            (whitespace-mode 1)))

;; Package: volatile-highlights
;; GROUP: Editing -> Volatile Highlights
(use-package volatile-highlights
  :init
  (volatile-highlights-mode t))

;; Package: undo-tree
;; GROUP: Editing -> Undo -> Undo Tree
;; (use-package undo-tree
;;   :init
;;   (global-undo-tree-mode 1))

;; Package: clean-aindent-mode
(use-package clean-aindent-mode
  :init
  (add-hook 'prog-mode-hook 'clean-aindent-mode))

;; Package: dtrt-indent
(use-package dtrt-indent
  :init
  (dtrt-indent-mode 1)
  (setq dtrt-indent-verbosity 0))

;; Package: ws-butler
(use-package ws-butler
  :init
  (add-hook 'prog-mode-hook 'ws-butler-mode)
  (add-hook 'text-mode 'ws-butler-mode)
  (add-hook 'fundamental-mode 'ws-butler-mode))

;; PACKAGE: comment-dwim-2
(use-package comment-dwim-2
  :bind (("M-;" . comment-dwim-2))
  )

;; PACKAGE: anzu
;; GROUP: Editing -> Matching -> Isearch -> Anzu
(use-package anzu
  :init
  (global-anzu-mode)
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))

;; PACKAGE: iedit
(use-package iedit
  :bind (("C-;" . iedit-mode))
  :init
  (setq iedit-toggle-key-default nil))

;; Customized functions
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "C-a") 'prelude-move-beginning-of-line)

(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
  line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

;; kill a line, including whitespace characters until next non-whiepsace character
;; of next line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))

;; taken from prelude-editor.el
;; automatically indenting yanked text if in programming-modes
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
Only modes that don't derive from `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes,
indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (not (member major-mode yank-indent-blacklisted-modes))
           (or (derived-mode-p 'prog-mode)
               (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of `yank-indent-modes',
indent yanked text (with prefix arg don't indent)."
  (when (and (not (ad-get-arg 0))
             (not (member major-mode yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
    (let ((transient-mark-mode nil))
      (yank-advised-indent-function (region-beginning) (region-end)))))

;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))

;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list)

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "C-c i") 'indent-region-or-buffer)

;; add duplicate line function from Prelude
;; taken from prelude-core.el
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line
or region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))

;; smart openline
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode.
With a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))

(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))

(global-set-key (kbd "M-o") 'prelude-smart-open-line)
(global-set-key (kbd "M-o") 'open-line)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require 'csv-mode)
#+END_SRC
* Helm
** Helm-gtags
#+BEGIN_SRC emacs-lisp
  ;; this variables must be set before load helm-gtags
  ;; you can change to any prefix key of your choice
  ;; (setq helm-gtags-prefix-key "\C-cg")

  ;; (use-package helm-gtags
  ;;   :init
  ;;   (progn
  ;;     (setq helm-gtags-ignore-case t
  ;;           helm-gtags-auto-update t
  ;;           helm-gtags-use-input-at-cursor t
  ;;           helm-gtags-pulse-at-cursor t
  ;;           helm-gtags-prefix-key "\C-cg"
  ;;           helm-gtags-suggested-key-mapping t)

  ;;     ;; Enable helm-gtags-mode in Dired so you can jump to any tag
  ;;     ;; when navigate project tree with Dired
  ;;     (add-hook 'dired-mode-hook 'helm-gtags-mode)

  ;;     ;; Enable helm-gtags-mode in languages that GNU Global supports
  ;;     (add-hook 'c-mode-hook 'helm-gtags-mode)
  ;;     (add-hook 'c++-mode-hook 'helm-gtags-mode)
  ;;     (add-hook 'java-mode-hook 'helm-gtags-mode)
  ;;     (add-hook 'asm-mode-hook 'helm-gtags-mode)

  ;;     ;; key bindings
  ;;     (with-eval-after-load 'helm-gtags
  ;;       (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
  ;;       (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
  ;;       (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
  ;;       (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
  ;;       (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
  ;;       (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history))))

  ;; (define-key helm-gtags-mode-map (kbd "C-c C-s") 'sr-speedbar-toggle)
  ;; (custom-set-variables
  ;;  '(speedbar-show-unknown-files t)
  ;;  )

#+END_SRC

** Other
#+BEGIN_SRC emacs-lisp
(use-package helm
  :init
  (progn
    (require 'helm-config)
    (require 'helm-grep)
    ;; To fix error at compile:
    ;; Error (bytecomp): Forgot to expand macro with-helm-buffer in
    ;; (with-helm-buffer helm-echo-input-in-header-line)
    (if (version< "26.0.50" emacs-version)
        (eval-when-compile (require 'helm-lib)))

    (defun helm-hide-minibuffer-maybe ()
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                  `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))

    (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-google-suggest-use-curl-p t
          helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
          ;; helm-quick-update t ; do not display invisible candidates
          helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.

          ;; you can customize helm-do-grep to execute ack-grep
          ;; helm-grep-default-command "ack-grep -Hn --smart-case --no-group --no-color %e %p %f"
          ;; helm-grep-default-recurse-command "ack-grep -H --smart-case --no-group --no-color %e %p %f"
          helm-split-window-in-side-p t ;; open helm buffer inside current window, not occupy whole other window

          helm-echo-input-in-header-line t

          ;; helm-candidate-number-limit 500 ; limit the number of displayed canidates
          helm-ff-file-name-history-use-recentf t
          helm-move-to-line-cycle-in-source t ; move to end or beginning of source when reaching top or bottom of source.
          helm-buffer-skip-remote-checking t

          helm-mode-fuzzy-match t

          helm-buffers-fuzzy-matching t ; fuzzy matching buffer names when non-nil
                                        ; useful in helm-mini that lists buffers
          helm-org-headings-fontify t
          ;; helm-find-files-sort-directories t
          ;; ido-use-virtual-buffers t
          helm-semantic-fuzzy-match t
          helm-M-x-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-lisp-fuzzy-completion t
          ;; helm-apropos-fuzzy-match t
          helm-buffer-skip-remote-checking t
          helm-locate-fuzzy-match t
          helm-display-header-line nil)

    (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

    (global-set-key (kbd "M-x") 'helm-M-x)
    (global-set-key (kbd "C-x C-m") 'helm-M-x)
    (global-set-key (kbd "M-y") 'helm-show-kill-ring)
    (global-set-key (kbd "C-x b") 'helm-buffers-list)
    (global-set-key (kbd "C-x C-f") 'helm-find-files)
    (global-set-key (kbd "C-c r") 'helm-recentf)
    (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
    (global-set-key (kbd "C-c h o") 'helm-occur)

    (global-set-key (kbd "C-c h w") 'helm-wikipedia-suggest)
    (global-set-key (kbd "C-c h g") 'helm-google-suggest)

    (global-set-key (kbd "C-c h x") 'helm-register)
    ;; (global-set-key (kbd "C-x r j") 'jump-to-register)

    (define-key 'help-command (kbd "C-f") 'helm-apropos)
    (define-key 'help-command (kbd "r") 'helm-info-emacs)
    (define-key 'help-command (kbd "C-l") 'helm-locate-library)

    ;; use helm to list eshell history
    (add-hook 'eshell-mode-hook
              #'(lambda ()
                  (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))

;;; Save current position to mark ring
    (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)

    ;; show minibuffer history with Helm
    (define-key minibuffer-local-map (kbd "M-p") 'helm-minibuffer-history)
    (define-key minibuffer-local-map (kbd "M-n") 'helm-minibuffer-history)

    (define-key global-map [remap find-tag] 'helm-etags-select)

    (define-key global-map [remap list-buffers] 'helm-buffers-list)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; PACKAGE: helm-swoop                ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Locate the helm-swoop folder to your path
    (use-package helm-swoop
      :bind (("C-c h o" . helm-swoop)
             ("C-c s" . helm-multi-swoop-all))
      :config
      ;; When doing isearch, hand the word over to helm-swoop
      (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)

      ;; From helm-swoop to helm-multi-swoop-all
      (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

      ;; Save buffer when helm-multi-swoop-edit complete
      (setq helm-multi-swoop-edit-save t)

      ;; If this value is t, split window inside the current window
      (setq helm-swoop-split-with-multiple-windows t)

      ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
      (setq helm-swoop-split-direction 'split-window-vertically)

      ;; If nil, you can slightly boost invoke speed in exchange for text color
      (setq helm-swoop-speed-or-color t))

    (helm-mode 1)

    (use-package helm-projectile
      :init
      (helm-projectile-on)
      (setq projectile-completion-system 'helm)
      (setq projectile-indexing-method 'alien))))
#+END_SRC

* File system infrastructure
** File system tree
*** Open .pdf, .avi etc
#+BEGIN_SRC emacs-lisp
  (use-package openwith)
  (openwith-mode t)
  (setq openwith-associations '(("\\.pdf\\'" "evince" (file))))
  (setq openwith-associations '(("\\.avi\\'" "vlc" (file))))
#+END_SRC

*** Dired
#+BEGIN_SRC emacs-lisp
  ;;(define-key dired-mode-map (kbd "<return>")   'dired-find-alternate-file)
(eval-after-load "dired" '(progn
  (define-key dired-mode-map (kbd "C-M-u")   'dired-up-directory) ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun dired-get-size ()
    (interactive)
    (let ((files (dired-get-marked-files)))
      (with-temp-buffer
        (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
        (message "Size of all marked files: %s"
                 (progn
                   (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                   (match-string 1))))))

(eval-after-load "dired" '(progn
  (define-key dired-mode-map (kbd "?") 'dired-get-size) ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC


#+BEGIN_SRC emacs-lisp
  ;; (load "/home/vkocheganov/.emacs.d/elpa/dired-launch-20180607.1841/dired-launch.el")
  ;; (dired-launch-enable)
  ;; (setq dired-launch-default-launcher '("xdg-open"))
  ;; (load "/home/vkocheganov/Development/github_sources/emacs/custom/diredp.el")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

*** Other
#+BEGIN_SRC emacs-lisp
  ;; (require 'sunrise)
#+END_SRC

** Shell/terminals
*** Shell
For proper processing of shell colors
#+BEGIN_SRC emacs-lisp
  (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;  (global-set-key "\M-\r" 'shell-resync-dirs)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;
  ;;;;;;;;;; To get colorized output from shell-mode ;;;;;;;;;;
  ;;
  ;; (require 'ansi-color)
  ;; (defun ansi-color-apply-on-buffer ()
  ;;     (ansi-color-apply-on-region (point-min) (point-max)))
  ;; (defun ansi-color-apply-on-minibuffer ()
  ;;   (let ((bufs (remove-if-not
  ;;                (lambda (x) (string-starts-with (buffer-name x) " *Echo Area"))
  ;;                (buffer-list))))
  ;;     (dolist (buf bufs)
  ;;       (with-current-buffer buf
  ;;         (ansi-color-apply-on-buffer)))))
  ;; (defun ansi-color-apply-on-minibuffer-advice (proc &rest rest)
  ;;   (ansi-color-apply-on-minibuffer))
  ;; (advice-add 'shell-command :after #'ansi-color-apply-on-minibuffer-advice)
  ;; (advice-remove 'shell-command #'ansi-color-apply-on-minibuffer-advice)
  ;; (defun add-test-function (cmd)
  ;;   (interactive "sCommand to run: ")
  ;;   (setq my-testall-test-function cmd)
  ;;   (defun my-testall ()
  ;;     (interactive)
  ;;     (shell-command my-testall-test-function))
  ;;   (local-set-key [f9] 'my-testall))
  ;; (defun my-shell-execute(cmd)
  ;;   (interactive "sShell command: ")
  ;;   (shell (get-buffer-create "my-shell-buf"))
  ;;   (process-send-string (get-buffer-process "my-shell-buf") (concat cmd "\n")))
  ;; (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC

Use company for shell completions
#+BEGIN_SRC emacs-lisp
(use-package company-shell
  :config
  (push 'company-shell company-backends)
  )
#+END_SRC

*** Term/vterm
#+BEGIN_SRC emacs-lisp
  ;; (use-package multi-term)
  ;; (setq multi-term-program "/bin/bash")
  ;; (define-key term-raw-map (kbd "C-c C-j") 'term-line-mode)

  ;; (add-to-list 'load-path "/home/vkocheganov/thirdparty/emacs-libvterm/")
  ;; (require 'vterm)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun vterm--rename-buffer-as-title (title)
    (let ((dir (string-trim-left (concat (nth 1 (split-string title ":")) "/"))))
      (cd-absolute dir)
      ))
  (add-hook 'vterm-set-title-functions #'vterm--rename-buffer-as-title)
#+END_SRC

*** ansi-term
#+BEGIN_SRC emacs-lisp
(defun my-term-mode-hook ()
  (define-key term-raw-map (kbd "C-y") 'term-paste)
  (define-key term-raw-map (kbd "C-k")
    (lambda ()
      (interactive)
      (term-send-raw-string "\C-k")
      (kill-line))))
(add-hook 'term-mode-hook 'my-term-mode-hook)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit)
  (global-unset-key "\C-xm")
  (global-set-key (kbd "\C-xms") 'magit-status)
#+END_SRC

* Languages
** General
Show unncessary whitespace that can mess up your diff
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda () (interactive)
            (setq show-trailing-whitespace 1)))
#+END_SRC

Whitespaces instead of TABS. Always
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Show parenthesis and highlight them
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

Electric indent
#+BEGIN_SRC emacs-lisp
;; (setq show-paren-style 'expression)
(electric-indent-mode nil)
(electric-pair-mode t)
#+END_SRC

Set appearance of a tab that is represented by 4 spaces
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

Compilation
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") (lambda ()
                                 (interactive)
                                 (setq-local compilation-read-command nil)
                                 (call-interactively 'compile)))
#+END_SRC

Projejctile project management tool.
Automatically indent when press RET
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (projectile-global-mode)
  (setq projectile-enable-caching t)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+END_SRC

Yas-snipets.
Usefull command: yas-describe-table
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config (use-package yasnippet-snippets)
    (yas-reload-all)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'org-mode-hook 'yas-minor-mode)
  )
  ;; (yas-global-mode)
#+END_SRC

** C/C++
C++ IDE setup
Guide: https://tuhdo.github.io/c-ide.html
*** GDB
Setup GDB
#+BEGIN_SRC emacs-lisp
(setq
 ;; use gdb-many-windows by default
 gdb-many-windows t
 ;; Non-nil means display source file containing the main routine at startup
 gdb-show-main t
 )
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq
 ;; use gdb-many-windows by default
 gdb-many-windows t

 ;; Non-nil means display source file containing the main routine at startup
 gdb-show-main t
 )

#+END_SRC

*** Generate tags
    Define function to create GTAGS files
    #+BEGIN_SRC emacs-lisp
      (defun create-tags (dir-name)
        "Create tags file."
        (interactive "DDirectory: ")
        (shell-command
         (format "gtags %s" (directory-file-name dir-name)))
        )
    #+END_SRC
    
*** Code-style
    Helm guide: https://tuhdo.github.io/helm-intro.html ;;;;;;;;;;
    Download helm-gtags: https://github.com/syohex/emacs-helm-gtags
    #+BEGIN_SRC emacs-lisp
        (defun my-c-mode-common-hook ()
        (c-set-style "Stroustrup")
        ;; Show lines
        (linum-mode 1)
        ;; Following command affects to c-toggle-auto-newline
        ;; That is automatically indent line after inserting
        ;; one of {, }, :, #, ;, ,, <, >, /, *, (, and ).
        (c-toggle-electric-state 1)
        ;; Indent size
        (setq c-basic-offset 4)
        ;; Enable autocomplition mode
        ;; (auto-complete-mode 1)
        ;; Do not insert new line after ';' or ','
        (setq c-hanging-semi&comma-criteria nil)
        (setq comment-start "//"  comment-end   "")
        )
      (add-hook 'c-mode-common-hook 'my-c-mode-common-hook)
    #+END_SRC
    
*** Setup-c
#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;; Company mode ;;;;;;;;;;
  ;;;;;;;;;; Auto completion ;;;;;;;;;;

  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))



  ;;(add-hook 'after-init-hook 'global-company-mode)

  ;;;;;;;;;; Hide/show blocks of code ;;;;;;;;;;
  ;;;;;;;;; C-c @ C-M-s show all
  ;;;;;;;;; C-c @ C-M-h hide all
  ;;;;;;;;; C-c @ C-s show block
  ;;;;;;;;; C-c @ C-h hide block
  ;;;;;;;;; C-c @ C-c toggle hide/show
  (add-hook 'c-mode-common-hook 'hs-minor-mode)

  ;; Available C style:
  ;; “gnu”: The default style for GNU projects
  ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
  ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
  ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
  ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
  ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
  ;; “linux”: What the Linux developers use for kernel development
  ;; “python”: What Python developers use for extension modules
  ;; “java”: The default style for java-mode (see below)
  ;; “user”: When you want to define your own style
  (setq c-default-style "stroustrup") ;; set style to "linux"

  ;;;;;;;;;;;; Highlighting ;;;;;;;;;;;;
  (use-package auto-highlight-symbol
    :ensure t)
  (add-hook 'c-mode-common-hook 'auto-highlight-symbol-mode)

  (use-package highlight-symbol)
  (global-set-key [(control f3)] 'highlight-symbol)
  (global-set-key [f3] 'highlight-symbol-next)
  (global-set-key [(shift f3)] 'highlight-symbol-prev)
  (global-set-key [(meta f3)] 'highlight-symbol-query-replace)
#+END_SRC

*** Setup-rtags
#+BEGIN_SRC emacs-lisp
  ;; In order to use rtags one should install it:
  ;; sudo apt-get install clang && sudo apt-get install libclang-dev
  ;; git clone --recursive https://github.com/Andersbakken/rtags.git && cd rtags && ./configure && make && sudo make install
  ;;
  ;; And create .dir-locals.el at project root:
  ;; ((nil . ((cmake-ide-build-dir . "/home/vkocheganov/thirdparty/opencv/build"))))
  ;;
  ;; To make cmake-ide work one needs project to be compiled with following flag:
  ;; cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .
  ;; If you don't have cmake, you should do something like:
  ;; bear --append make -j16
  ;; rdm &
  ;; rc -J .

  ;; See https://vxlabs.com/2016/04/11/step-by-step-guide-to-c-navigation-and-completion-with-emacs-and-the-clang-based-rtags/
  ;; for more details

  (load-file "~/thirdparty/rtags/src/rtags.el")
  ;; (use-package rtags)
  ;; (require 'rtags)
  ;; (add-hook 'c-mode-hook 'rtags-start-process-unless-running)
  ;; (add-hook 'c++-mode-hook 'rtags-start-process-unless-running)
  ;; (add-hook 'objc-mode-hook 'rtags-start-process-unless-running)
  ;; (use-package cmake-ide)
  ;; (cmake-ide-setup)
  (rtags-enable-standard-keybindings c-mode-base-map "\C-xr")
  (define-key c-mode-base-map (kbd "M-.")
    (function rtags-find-symbol-at-point))
  (define-key c-mode-base-map (kbd "M-,")
    (function rtags-find-references-at-point))


  ;;;; Begin auto completions section
  ;;;;
  ;; comment this out if you don't have or don't use helm
  (setq rtags-use-helm t)
  ;; company completion setup
  (setq rtags-autostart-diagnostics t)
  (rtags-diagnostics)
  (setq rtags-completions-enabled t)
  (push 'company-rtags company-backends)
  ;; (global-company-mode)
  (define-key c-mode-base-map (kbd "<C-tab>") (function company-complete))
  (define-key c-mode-base-map (kbd "<C-backspace>") (function rtags-location-stack-back))
  ;;;;
  ;;;; End auto completions section


  ;; use rtags flycheck mode -- clang warnings shown inline
  (use-package flycheck-rtags)
  ;; c-mode-common-hook is also called by c++-mode

  (defun setup-flycheck-rtags ()
    (interactive)
    (flycheck-select-checker 'rtags)
    ;; RTags creates more accurate overlays.
    (setq-local flycheck-highlighting-mode nil)
    (setq-local flycheck-check-syntax-automatically nil))
  (add-hook 'c-mode-common-hook #'setup-flycheck-rtags)
  (add-hook 'c++-mode-hook #'setup-flycheck-rtags)

  ;; (use-package helm-rtags)
  ;; (setq rtags-display-result-backend 'helm)
  ;; (use-package ivy-rtags)
  ;; (setq rtags-display-result-backend 'ivy)


#+END_SRC
** Python
  #+BEGIN_SRC emacs-lisp
    (setq python-command "/usr/bin/python3.4")
    ;; (use-package posframe)
    (use-package anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-mode)
    (eval-after-load 'python
      '(define-key python-mode-map "\C-xpb" 'python-nav-backward-block))
    (eval-after-load 'python
      '(define-key python-mode-map "\C-xpl" 'python-nav-backward-up-list))
    (eval-after-load 'python
      '(define-key python-mode-map "\C-xpf" 'python-nav-forward-block))
    (eval-after-load 'python
      '(define-key python-mode-map "\C-xpm" 'python-mark-defun))
    (eval-after-load 'python
      '(define-key python-mode-map "\C-xpm" 'python-mark-defun))
    (eval-after-load 'python
      '(define-key python-mode-map "\M-i" 'anaconda-mode-complete))
  #+END_SRC



#+BEGIN_SRC emacs-lisp
  
#+END_SRC


#+BEGIN_SRC emacs-lisp
  
#+END_SRC


#+BEGIN_SRC emacs-lisp
  
#+END_SRC


#+BEGIN_SRC emacs-lisp
  
#+END_SRC


#+BEGIN_SRC emacs-lisp
  
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
  ;; (defun my-lua-mode-hook ()
  ;;   (setq lua-indent-level 4)
  ;;   )
  ;; (add-hook 'lua-mode-hook 'my-lua-mode-hook)
#+END_SRC

* Usefull routines
** htop
#+BEGIN_SRC emacs-lisp
  (defun htop ()
    (interactive)
    (if (get-buffer "*htop*")
        (switch-to-buffer "*htop*")
      (ansi-term "/bin/bash" "htop")
      (comint-send-string "*htop*" "htop\n")))
#+END_SRC

** Up/down scrolling
Make 'up' and 'down' keyboard keys do scrolling (instead of moving)
#+BEGIN_SRC emacs-lisp
(defun gcm-scroll-up ()
  (interactive)
  (scroll-down 1))
(defun gcm-scroll-down ()
  (interactive)
  (scroll-up 1))
(global-set-key [(down)] 'gcm-scroll-down)
(global-set-key [(up)]   'gcm-scroll-up)
#+END_SRC
** Copy-file-name
#+BEGIN_SRC emacs-lisp
(defun copy-file-name ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

* Uncle Dave stuff
#+BEGIN_SRC emacs-lisp
  ;;
  ;; Configure ansi-term launch
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
  (global-set-key (kbd "M-RET") 'ansi-term)
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;;
  ;; Kill current buffer if no args passed
  ;; Act as usual kill if run with C-u
  (defun victor-kill-buffer (arg)
    "kill current buffer"
    (interactive "P")
    (if arg
      (call-interactively 'kill-buffer)
        (kill-buffer)
    ))
  (global-set-key (kbd "C-x k") 'victor-kill-buffer)

  ;; move cursor more continuosly at the window end
  (setq scroll-conservatively 100)

  ;;
  ;; Highlight current line
  (global-hl-line-mode t)
  (set-face-background hl-line-face "gray13")
  ;; (set-face-attribute hl-line-face nil  :foreground "white")
  ;; (set-face-attribute hl-line-face nil :underline t)
  (set-face-background 'highlight "gray13")
  (set-face-foreground 'highlight nil)
  ;; (set-face-underline-p 'highlight t)

  ;;
  ;; When scrolling beacon mode shortly highlights last line
  (use-package beacon
    :ensure t
    :init )
  (beacon-mode 1)

  (setq make-backup-files nil)

  ;; This is likely usefull in terminal
  ;; (use-package org-bullets
  ;; :ensure t
  ;; :config 
  ;; (add-hook  'org-mode-hook (lambda () (org-bulltes-mode))))

(use-package async
  :init (dired-async-mode 1))
#+END_SRC

Dangerous key binding:
#+BEGIN_SRC emacs-lisp
  ;; (define-key org-mode-map (kbd "C-c C-c") 'org-edit-src-code)
#+END_SRC

* Key-bindings
** Fast folder access (<F*> keys)
#+BEGIN_SRC emacs-lisp
  (defun revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive) (revert-buffer t t))
  (global-set-key (kbd "<f5>") 'revert-buffer-no-confirm)
  (global-set-key (kbd "C-<f5>") 'compile)

  (global-set-key (kbd "<f6>") (lambda() (interactive)(find-file "/home/vkocheganov/mounted/NAS/homes_Viktor.Kocheganov/VDC/data/")))
  (global-set-key (kbd "<f7>") (lambda() (interactive)(find-file "/ssh:ts13:/home/vkocheganov/link_training/vic_models/")))
  (global-set-key (kbd "<f8>") (lambda() (interactive)(find-file "/ssh:dl4:/home/vkocheganov/VDC/VideoAnnotation/")))
#+END_SRC
* gnuplot
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)
  (use-package gnuplot-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width nil)
#+END_SRC
